#!/usr/bin/env python3
# encoding: utf-8

""" automated test framework for panzer

runtests.py panzer|pandoc [source1 source2 ...]

this will:
    -   run panzer on series of source files, dumping output to output-panzer/
    -   run pandoc on series of source files, dumping output to output-pandoc/

you can then diff the two output directories using the diff of your choice
if the two outputs don't match, panzer fails on that source file

spec.py contains all the info that specifies which tests will be run on each source file
at the moment, this is a list of writers to test, plus a list of command line options for pandoc that get run in every possible comination

all this is not currently fully implemented (i.e. it is not working)

to write a new test:
    -   write panzer source file
    -   write pandoc source file that will produce the same output file
    -   write json ouput that is correct to use as benchmark

- the json messages to check against will either have to be generated by hand (via past correct run of panzer), or with some kind of 'hint' file (not implemented yet)

for more info: <https://github.com/msprev/panzer>

Author    : Mark Sprevak <mark.sprevak@ed.ac.uk>
Copyright : Copyright 2014, Mark Sprevak
License   : BSD3
"""

import os
import subprocess
import itertools
import shutil
import spec
import time
import datetime
import sys

def main():
    """ the main function """
    remit, sourcelist = parse_cli(sys.argv)
    if not remit:
        exit(1)
    if not sourcelist:
        sourcelist = get_all_sources(remit)
    describe_tests(remit, sourcelist)
    print('Delete old output files of %s for these tests?' % remit)
    input("Press Enter to continue...")
    clean_outputs(remit, sourcelist)
    print('Run tests now?')
    input("Press Enter to continue...")
    print('Changing working directory to "source-%s"' % remit)
    os.chdir('source-' + remit)
    print(pretty_title('start'))
    start_time = time.time()
    run_tests(remit, sourcelist)
    print(pretty_title('end'))
    elapsed_time = time.time() - start_time
    print('time taken: %s (%f seconds)'
          % (str(datetime.timedelta(seconds=elapsed_time)),
             elapsed_time))

def parse_cli(argv):
    """ return remit and sourcelist by parsing cli arguments """
    sourcelist = list()
    remit = None
    if len(argv) < 2 \
    or (argv[1] != 'pandoc' and argv[1] != 'panzer'):
        print('syntax: runtest.py REMIT [SOURCE1] [SOURCE2] ...')
        print('     where REMIT could be "pandoc" or "panzer"')
        print('     if no sources specified, then all tests are run')
        sys.exit(1)
    if len(argv) == 2:
        remit = argv[1]
    if len(argv) > 2:
        sourcelist = argv[2:]
    return remit, sourcelist

def get_all_sources(remit):
    """ return sourcelist populated with all sources """
    os.chdir('source-'+remit)
    sourcelist = [name for name in os.listdir(".") if os.path.isdir(name)]
    os.chdir('..')
    return sourcelist

def describe_tests(remit, sourcelist):
    """ print info about tests to be run """
    print('* test run for "%s"' % remit)
    print('* files to test: ')
    print('    ' + str(sourcelist))
    print('* writers to test: ')
    print('    ' + str(spec.TEST['writer']))
    print('* pandoc options to test: ')
    print('    ' + str(spec.TEST['pandoc_options']))

def clean_outputs(remit, sourcelist):
    """ delete the output files for all the sources of remit """
    for source in sourcelist:
        os.chdir('output-'+remit)
        if os.path.exists(source):
            shutil.rmtree(source)
            print('* deleted old "output-%s/%s"' % (remit, source))
        os.mkdir(source)
        os.chdir(source)
        os.mkdir('debug')
        os.chdir('..')
        os.chdir('..')

def run_tests(remit, sourcelist):
    """ run all the tests for remit on sourcelist """
    for source in sourcelist:
        print(pretty_title(source))
        # - move into source's directory
        os.chdir(source)
        # - build worklist of commands
        commands = list()
        commands += test_matrix(remit, source)
        commands += extra_tests(remit, source)
        commands = remove_blacklist(remit, source, commands)
        # - run the commands
        for i, command in enumerate(commands):
            print('[%s:%d/%d] %s'
                  % (source, i+1, len(commands), ' '.join(command)))
            # subprocess.call(command)
        # - move out of source's directory
        os.chdir('..')

def test_matrix(remit, source):
    """ return worklist of commands for all combinations of TEST on source """
    # - list of all combinations of pandoc_options
    combos = [list(set(x))
              for x in list(itertools.combinations_with_replacement(
                  spec.TEST['pandoc_options'],
                  len(spec.TEST['pandoc_options'])))]
    # - remove duplicates from list
    combos.sort()
    combos = list(combos for combos, _ in itertools.groupby(combos))
    # - add the 'no options' option at the start of list
    combos.insert(0, [])
    commands = list()
    # - create worklist for every writer and combination of pandoc_options
    for config in itertools.product(spec.TEST['writer'], combos):
        command = make_command(remit=remit,
                               source=source,
                               writer=config[0],
                               pandoc_options=config[1])
        commands.append(command)
    return commands

def extra_tests(remit, source):
    """ return commands for running EXTRA_TESTS """
    commands = list()
    for config in spec.EXTRA_TESTS:
        command = make_command(remit=remit,
                               source=source,
                               writer=config['writer'],
                               pandoc_options=config['pandoc_options'],
                               extension=config['extension'])
        commands.append(command)
    return commands

def remove_blacklist(remit, source, commands):
    """ return worklist with anything in BLACKLIST removed """
    return commands

def make_command(remit=str(),
                 source=str(),
                 writer=str(),
                 extension=str(),
                 pandoc_options=str()):
    """ return command to run remit on source based on arguments """
    # if no extension specified, infer it from writer
    if not extension and writer:
        if writer in spec.DEFAULT_EXTENSION:
            extension = spec.DEFAULT_EXTENSION[writer]
        else:
            print('WARNING: No known extension for writer "%s", '
                  'using ".UNKNOWN"' % writer)
            extension = '.UNKNOWN'
    # start building the command...
    # remit
    command = [remit]
    # source
    command += [source + '.md']
    # writer
    if writer:
        command += ['-t']
        command += [writer]
    # other options
    command.extend(pandoc_options)
    # output
    # - first build output filename...
    if writer == '':
        pretty_writer_string = 'default'
    else:
        pretty_writer_string = writer
    target = os.path.join(os.getcwd(), '..', '..', 'output-'+remit,
                          source, source)
    target = os.path.normpath(target)
    command += ['-o']
    command += [target
                + "_"
                + pretty_writer_string
                + ''.join(pandoc_options)
                + extension]
    # panzer-specific options
    if remit == 'panzer':
        command += ['---debug']
        target = os.path.join(os.getcwd(), '..', '..', 'output-'+remit,
                              source, 'debug', 'debug_' + source)
        target = os.path.normpath(target)
        command += [target
                    + "_"
                    + pretty_writer_string
                    + ''.join(pandoc_options)]
    # done!
    return command

def pretty_title(title):
    """ return pretty printed section title """
    output = '-' * 5 + ' ' + title + ' ' + '-' * 5
    return output


if __name__ == '__main__':
    main()
